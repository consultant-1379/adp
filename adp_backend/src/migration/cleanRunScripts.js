// ============================================================================================= //
/**
* [ global.adp.migration.cleanRunScripts ]
* Run the Migration Scripts, following the object generated by
* global.adp.migration.cleanGetPermissionToRun and global.adp.migration.cleanGetAllAssets.
* There is some internal recursive functions in this file:
* === applyRule();
* ====== nextDoc();
* ====== nextRule();
* ====== saveAllChangesInDatabase();
* === saveAllChangesInDatabase();
* ====== updateNext();
* ====== thisIsTheLastChangeOfThisAsset();
* Documentation: https://confluence-oss.seli.wh.rnd.internal.ericsson.com/display/ADP/Backend+Migration+Script
* @author Armando Dias [zdiaarm], Omkar Sadegaonkar [zsdgmkr]
*/
// ============================================================================================= //
/* eslint-disable no-use-before-define */
/* eslint-disable no-param-reassign */
/* eslint-disable no-underscore-dangle */
// ============================================================================================= //
global.adp.docs.list.push(__filename);
// ============================================================================================= //
module.exports = RULESASSETS => new Promise((RESOLVE, REJECT) => {
  // ------------------------------------------------------------------------------------------- //
  // Variables
  const timer = new Date();
  const packName = 'global.adp.migration.cleanRunScripts';
  const changesToApply = [];
  let docIndex = 0;
  let ruleDBIndex = 0;
  let ruleIndex = 0;
  const assetIndexLimit = RULESASSETS.allassets.length - 1;
  const userIndexLimit = RULESASSETS.allUsers.length - 1;
  let changesToApplyIndex = 0;
  let changesToApplyLimit = 0;
  let ruleIndexLimit = 0;
  let ruleDBIndexLength = 0;
  if (RULESASSETS.migrationscripts !== undefined) {
    if (RULESASSETS.migrationscripts.doc !== undefined) {
      ruleIndexLimit = RULESASSETS.migrationscripts.doc.length - 1;
    }
    if (RULESASSETS.migrationscripts.database !== undefined) {
      ruleDBIndexLength = RULESASSETS.migrationscripts.database.length;
    }
  }
  // ------------------------------------------------------------------------------------------- //
  const applyRuleForDatabase = async () => {
    if (ruleDBIndexLength > ruleDBIndex) {
      const thisDBRule = RULESASSETS.migrationscripts.database[ruleDBIndex];
      const scriptDBIsThere = typeof global.adp.migration[thisDBRule.commandName] !== 'undefined';
      const temporaryException = (thisDBRule.commandName === 'scriptFromCouchToMongo');
      if (scriptDBIsThere && !temporaryException) {
        try {
          await global.adp.migration[thisDBRule.commandName]()
            .then(async () => {
              await global.adp.migration.cleanUpdatePermissionToRun(thisDBRule.commandName)
                .then(() => {
                  ruleDBIndex += 1;
                  if (ruleDBIndex <= ruleDBIndexLength) {
                    applyRuleForDatabase();
                  } else {
                    applyRule();
                  }
                })
                .catch((ERROR) => {
                  const obj = {
                    commandName: thisDBRule.commandName,
                    error: ERROR,
                  };
                  adp.echoLog('Error in [ adp.migration.cleanUpdatePermissionToRun ]', obj, 500, packName, true);
                });
            })
            .catch((ERROR) => {
              const obj = {
                commandName: thisDBRule.commandName,
                error: ERROR,
              };
              adp.echoLog(`Error in [ adp.migration[${thisDBRule.commandName}]() ]`, obj, 500, packName, true);
            });
        } catch (ERROR) {
          adp.echoLog('Caught an error in try/catch', ERROR, 500, packName, true);
        }
      } else {
        if (temporaryException) {
          adp.echoLog('The script [ fromCouchToMongo ] cannot run if [ mongoDB ] is the default database.', null, 200, packName, false);
        }
        ruleDBIndex += 1;
        applyRuleForDatabase();
      }
    } else {
      applyRule();
    }
  };
  // ------------------------------------------------------------------------------------------- //
  // applyRule();
  // Verify if Migration Script is loaded in memory and available for use.
  // Apply the Rule of each Migration Script, in order, waiting for the previous process.
  // call nextDoc() to give another step Asset after Asset.
  // call nextRule() when finishe all Assets and need to move to the next Rule.
  // IMPORTANT: The Migration Scripts always return a Promise. This Promise need to be
  // fulfilled before start the next Promise.
  // This is necessary to avoid the lost of changes generated by
  // many Migration Scripts on the same Asset.
  const applyRule = () => {
    const thisRule = RULESASSETS.migrationscripts.doc[ruleIndex];
    if (thisRule === undefined) {
      nextRule();
      return;
    }
    const scriptIsThere = typeof global.adp.migration[thisRule.commandName] !== 'undefined';
    if (scriptIsThere) {
      const thisDoc = thisRule.focus === 'user' ? RULESASSETS.allUsers[docIndex] : RULESASSETS.allassets[docIndex];
      global.adp.migration[thisRule.commandName](thisDoc)
        .then((RULEAPPLIED) => {
          if (RULEAPPLIED !== true) {
            if (thisRule.applyRule === true) {
              if (thisRule.focus === 'user') {
                RULESASSETS.allUsers[docIndex] = RULEAPPLIED;
              } else {
                RULESASSETS.allassets[docIndex] = RULEAPPLIED;
              }
            }
            const toUpdate = {
              ruleName: thisRule.commandName,
              ruleActive: thisRule.applyRule,
              assetID: thisDoc._id,
              assetName: thisDoc.name,
              asset: RULEAPPLIED,
            };
            changesToApply.push(toUpdate);
          }
          nextDoc(thisRule.focus);
        })
        .catch((ERROR) => {
          const obj = {
            error: ERROR,
            thisDoc,
          };
          adp.echoLog(`Error in [ adp.migration[${thisRule.commandName}](thisDoc) ]`, obj, 500, packName, true);
        });
    } else {
      adp.echoLog(`The command [ global.adp.migration.${thisRule.commandName} ] was not found in the code.`, null, 200, packName);
      nextRule();
    }
  };
  // ------------------------------------------------------------------------------------------- //
  // nextDoc();
  // This moves the assetIndex forward and call applyRule();
  // If there is no more Assets, calls nextRule();
  const nextDoc = (focus = 'asset') => {
    docIndex += 1;
    const limitIndex = focus === 'asset' ? assetIndexLimit : userIndexLimit;
    if (docIndex <= limitIndex) {
      applyRule();
    } else {
      nextRule();
    }
  };
  // ------------------------------------------------------------------------------------------- //
  // nextRule();
  // This moves the ruleIndex forward, resets the assetIndex and call applyRule();
  // If there is no more Rules, call saveAllChangesInDatabase();
  const nextRule = () => {
    ruleIndex += 1;
    if (ruleIndex <= ruleIndexLimit) {
      docIndex = 0;
      applyRule();
    } else {
      saveAllChangesInDatabase();
    }
  };
  // ------------------------------------------------------------------------------------------- //
  // saveAllChangesInDatabase();
  // If allowed, saves the changes in Database.
  // If one Asset was changed twice or more times, only the last instance, containing all changes,
  // is updated on Database.
  // Calls thisIsTheLastChangeOfThisAsset() to check if this is the last change.
  // If the Migration Script is blocked by Permission ( runOnce is true and there is lastRun date )
  // but the Asset do not match the necessity, a warning will be displayed:
  // {{{ "${assetName}" need to be updated by "${ruleName}" rule, but this rule is disabled. }}}
  // This function runs in order, one update should wait for the conclusion of the previous update,
  // to proceeed. The updateNext() is called at the end of each update.
  const saveAllChangesInDatabase = () => {
    const adpModel = new adp.models.Adp();
    if (changesToApply.length === 0) {
      RESOLVE();
      return;
    }
    const {
      ruleName, ruleActive, assetName, asset,
    } = changesToApply[changesToApplyIndex];
    if (ruleActive === true) {
      delete asset._rev;
      if (thisIsTheLastChangeOfThisAsset(changesToApplyIndex) === true) {
        adpModel.update(asset)
          .then(() => {
            adp.echoLog(`"${assetName}" was updated on Database by "${ruleName}" rule.`, null, 200, packName);
            updateNext();
          })
          .catch((ERROR) => {
            adp.echoLog(`|| ERROR || "${assetName}" cannot be updated by "${ruleName}" rule`, { error: ERROR }, 500, packName, true);
            const endTimer = new Date() - timer;
            const errorMSG = `Error in ${endTimer}ms through [${packName}] :: ${ERROR}`;
            REJECT(errorMSG);
          });
      } else {
        adp.echoLog(`"${assetName}" was changed by "${ruleName}" rule.`, null, 200, packName);
        updateNext();
      }
    } else {
      adp.echoLog(`|| WARNING || "${assetName}" need to be updated by "${ruleName}" rule, but this rule is disabled.`, null, 200, packName);
      updateNext();
    }
  };
  // ------------------------------------------------------------------------------------------- //
  // updateNext();
  // Move changesToApplyIndex forward and calls saveAllChangesInDatabase() to execute
  // the next update. If there is nothing more, RESOLVE and finish the main Promise.
  const updateNext = () => {
    changesToApplyIndex += 1;
    changesToApplyLimit = changesToApply.length - 1;
    if (changesToApplyIndex <= changesToApplyLimit) {
      saveAllChangesInDatabase();
    } else {
      const updateRulesDatesOf = new Map();
      const updateRulesDatesOfArray = [];
      changesToApply.forEach((ITEM) => {
        if (!updateRulesDatesOf.has(ITEM.ruleName)) {
          updateRulesDatesOf.set(ITEM.ruleName, true);
          updateRulesDatesOfArray.push(ITEM.ruleName);
        }
      });
      global.adp.migration.cleanUpdatePermissionToRun(updateRulesDatesOfArray)
        .then(() => {
          RESOLVE();
        })
        .catch((ERROR) => {
          const endTimer = new Date() - timer;
          adp.echoLog(`Error in [ adp.migration.cleanUpdatePermissionToRun ] in ${endTimer}ms`, { error: ERROR }, 500, packName, true);
          const errorMSG = `Error in ${endTimer}ms through [ ${packName} ]`;
          REJECT(errorMSG);
        });
    }
  };
  // ------------------------------------------------------------------------------------------- //
  // thisIsTheLastChangeOfThisAsset();
  // Check if the current instance is unique or if is the last in the queue.
  // To avoid unecessary updates in Database, only the last instance of each Asset, containing
  // all the changes, will be updated. So, returns TRUE or FALSE. If TRUE, can be updated.
  const thisIsTheLastChangeOfThisAsset = (INDEX) => {
    let haveBigger = false;
    const id = changesToApply[INDEX].asset._id;
    if (changesToApplyLimit === 0) {
      changesToApplyLimit = changesToApply.length - 1;
    }
    let iLoop = 0;
    changesToApply.forEach((ITEM) => {
      if (ITEM.asset !== undefined) {
        const theIDAreEqual = ITEM.asset._id === id;
        const theILoopIsBiggerThanINDEX = (iLoop > INDEX);
        if (theIDAreEqual && theILoopIsBiggerThanINDEX) {
          haveBigger = true;
        }
      }
      iLoop += 1;
    });
    if (haveBigger) {
      return false;
    }
    return true;
  };
  // ------------------------------------------------------------------------------------------- //
  // Start the action:
  applyRuleForDatabase();
  // ------------------------------------------------------------------------------------------- //
});
// ============================================================================================= //
